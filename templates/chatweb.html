<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>MINI AI</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Existing Fonts and Styles -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Mulish:ital,wght@0,200..1000;1,200..1000&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/index.css', cache_timeout=0) }}">  
    <link rel="shortcut icon" href="{{ url_for('static', filename='images/ico.svg') }}" type="image/x-icon">
    <!-- Removed integrity attributes -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css" crossorigin="anonymous">
    
    <!-- Existing JS Libraries -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.9.2/html2pdf.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.4.0/purify.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@latest/lib/index.iife.min.js"></script>

    <script>
    
        document.addEventListener('DOMContentLoaded', async () => {
        // Constants
        const TOKEN_MINT_ADDRESS = '9nmu7zbf1kKNb52cAohAzyjD3yRdG8Pszw15Umsupump';  // Token MINI mint address
        const TOKEN_DECIMALS = 6;  // Correct number of decimals for your SPL token
        const TOKEN_MINT_PUBLIC_KEY = new solanaWeb3.PublicKey(TOKEN_MINT_ADDRESS);
        const TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
        const ASSOCIATED_TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"); // Use the same ID as in the working code
        const BACKEND_GET_COST_URL = '/get_cost_publish';
        const BACKEND_PUBLISH_ACTION_URL = '/publish_action_website';
        const HASHCHAT = '{{hashchatsession}}';
        
        // Add the custom RPC_URL
        const RPC_URL = '{{endpoint_solana}}'; // Replace with your own QuickNode URL
        
        // DOM elements
        const connectWalletButton = document.getElementById('connect-wallet-button');
        
        // Polling function to confirm transaction with timeout
        async function waitForConfirmation(connection, signature, timeout = 120000, interval = 5000) {
            const startTime = Date.now();
        
            return new Promise((resolve, reject) => {
                const timer = setInterval(async () => {
                    try {
                        const status = await connection.getSignatureStatus(signature);
                        const confirmation = status && status.value && (status.value.confirmationStatus === 'confirmed' || status.value.confirmationStatus === 'finalized');
        
                        if (confirmation) {
                            clearInterval(timer);
                            resolve(status.value);
                        } else if (Date.now() - startTime > timeout) {
                            clearInterval(timer);
                            reject(new Error('Transaction confirmation timeout exceeded.'));
                        }
                    } catch (error) {
                        clearInterval(timer);
                        reject(error);
                    }
                }, interval);
            });
        }
        
        connectWalletButton.addEventListener('click', async () => {
            if (window.solana && window.solana.isPhantom) {
                try {
                    // Connect to Phantom Wallet
                    const resp = await window.solana.connect();
                    const userPublicKey = resp.publicKey;
                    const walletAddress = userPublicKey.toString();
        
                    // Send wallet and hashchat to the backend to get the cost
                    const response = await fetch(BACKEND_GET_COST_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            wallet: walletAddress,
                            hashchat: HASHCHAT
                        })
                    });
        
                    const data = await response.json();
                    if (data.error) {
                        alert('Error retrieving cost: ' + data.error);
                        return;
                    }
        
                    const costAmount = data.cost_amount; // Assuming it's a number or string
        
                    // Convert amount to correct format
                    const tokenAmount = Math.round(parseFloat(costAmount) * Math.pow(10, TOKEN_DECIMALS));
        
                    // Establish connection to Solana network using the custom RPC
                    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
        
                    // Project wallet address
                    const PROJECT_WALLET_ADDRESS = '{{ wallet_project }}';
                    const PROJECT_PUBLIC_KEY = new solanaWeb3.PublicKey(PROJECT_WALLET_ADDRESS);
        
                    // Get or create associated token accounts
                    const userTokenAccountAddress = await getAssociatedTokenAddress(TOKEN_MINT_PUBLIC_KEY, userPublicKey);
                    const projectTokenAccountAddress = await getAssociatedTokenAddress(TOKEN_MINT_PUBLIC_KEY, PROJECT_PUBLIC_KEY);
        
                    const transaction = new solanaWeb3.Transaction();
        
                    // Check if the user's associated token account exists and has sufficient balance
                    const userTokenAccountInfo = await connection.getAccountInfo(userTokenAccountAddress);
        
                    let sourceTokenAccount = null;
        
                    if (userTokenAccountInfo !== null) {
                        // ATA exists, check if it has sufficient balance
                        const tokenAccountBalanceResponse = await connection.getTokenAccountBalance(userTokenAccountAddress);
                        const tokenAccountBalance = parseInt(tokenAccountBalanceResponse.value.amount);
        
                        if (tokenAccountBalance >= tokenAmount) {
                            sourceTokenAccount = userTokenAccountAddress;
                        }
                    }
        
                    // If no sufficient balance found in the ATA, search other accounts
                    if (!sourceTokenAccount) {
                        // Get all user's token accounts for the specific mint
                        const tokenAccounts = await connection.getParsedTokenAccountsByOwner(userPublicKey, {
                            mint: TOKEN_MINT_PUBLIC_KEY
                        });
        
                        // Look for an account with sufficient balance
                        for (let accountInfo of tokenAccounts.value) {
                            const balance = parseInt(accountInfo.account.data.parsed.info.tokenAmount.amount);
                            if (balance >= tokenAmount) {
                                sourceTokenAccount = accountInfo.pubkey;
                                break;
                            }
                        }
                    }
        
                    if (!sourceTokenAccount) {
                        alert('You don’t have enough tokens to send.');
                        return;
                    }
        
                    // Check if the project's associated token account exists
                    const projectTokenAccountInfo = await connection.getAccountInfo(projectTokenAccountAddress);
                    if (projectTokenAccountInfo === null) {
                        // Create the project's associated token account
                        const createProjectATAIx = createAssociatedTokenAccountInstruction(
                            userPublicKey, // Payer (user pays for creation)
                            projectTokenAccountAddress, // ATA to create
                            PROJECT_PUBLIC_KEY, // Owner
                            TOKEN_MINT_PUBLIC_KEY
                        );
                        transaction.add(createProjectATAIx);
                    }
        
                    // Create transfer instruction
                    const transferIx = createTransferCheckedInstruction(
                        sourceTokenAccount,
                        TOKEN_MINT_PUBLIC_KEY,
                        projectTokenAccountAddress,
                        userPublicKey,
                        tokenAmount,
                        TOKEN_DECIMALS
                    );
        
                    transaction.add(transferIx);
        
                    // Set fee payer and recent blockhash
                    transaction.feePayer = userPublicKey;
                    const latestBlockhash = await connection.getLatestBlockhash();
                    transaction.recentBlockhash = latestBlockhash.blockhash;
        
                    // Sign and send the transaction
                    const signedTransaction = await window.solana.signTransaction(transaction);
                    const signature = await connection.sendRawTransaction(signedTransaction.serialize());
        
                    // Wait for transaction confirmation with a 2-minute timeout
                    try {
                        await waitForConfirmation(connection, signature, 120000, 5000);
                        alert('Payment successful! Transaction signature: ' + signature);
                    } catch (confirmationError) {
                        console.error('Transaction confirmation error:', confirmationError);
                        alert('The transaction is pending or failed. Please check the signature on Solana Explorer: ' + signature);
                        return;
                    }
        
                    // After successful payment, send data to the backend to publish the website
        
                    const publishResponse = await fetch(BACKEND_PUBLISH_ACTION_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            signature_tx: signature,
                            hashchat: HASHCHAT
                        })
                    });
        
                    const publishData = await publishResponse.json();
                    if (publishData.error) {
                        alert('Error publishing website: ' + publishData.error);
                    } else {
                        alert('Website published successfully! Your URL is: /website/' + publishData.url_web);
                        // Optionally, redirect the user to their new website
                        window.location.href = '/website/' + publishData.url_web;
                    }
        
                } catch (err) {
                    console.error('An error occurred:', err);
                    alert('An error occurred: ' + err.message);
                }
            } else {
                alert('Phantom Wallet not detected. Please install the Phantom Wallet extension.');
            }
        });
        
        
        // Functions to handle SPL tokens without the spl-token library
        async function getAssociatedTokenAddress(mint, owner) {
            return (await solanaWeb3.PublicKey.findProgramAddress(
                [
                    owner.toBuffer(),
                    TOKEN_PROGRAM_ID.toBuffer(),
                    mint.toBuffer(),
                ],
                ASSOCIATED_TOKEN_PROGRAM_ID
            ))[0];
        }
        
        function createAssociatedTokenAccountInstruction(payer, ata, owner, mint) {
            const keys = [
                { pubkey: payer, isSigner: true, isWritable: true },
                { pubkey: ata, isSigner: false, isWritable: true },
                { pubkey: owner, isSigner: false, isWritable: false },
                { pubkey: mint, isSigner: false, isWritable: false },
                { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false },
                { pubkey: solanaWeb3.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
                { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            ];
            return new solanaWeb3.TransactionInstruction({
                keys,
                programId: ASSOCIATED_TOKEN_PROGRAM_ID,
                data: new Uint8Array(0),
            });
        }
        
        function createTransferCheckedInstruction(source, mint, destination, owner, amount, decimals) {
            const data = new Uint8Array(10);
            const dataView = new DataView(data.buffer);
        
            dataView.setUint8(0, 12); // Instruction index for TransferChecked
            dataView.setBigUint64(1, BigInt(amount), true); // Amount in little-endian
            dataView.setUint8(9, decimals); // Token decimals
        
            const keys = [
                { pubkey: source, isSigner: false, isWritable: true },
                { pubkey: mint, isSigner: false, isWritable: false },
                { pubkey: destination, isSigner: false, isWritable: true },
                { pubkey: owner, isSigner: true, isWritable: false },
            ];
        
            return new solanaWeb3.TransactionInstruction({
                keys,
                programId: TOKEN_PROGRAM_ID,
                data: data,
            });
        }
        });
        </script>
        
        
    <style>
        /* Basic Reset */
        * {
            box-sizing: border-box;
            font-family: 'Mulish', sans-serif;
        }
        
        .audio-player {
    background: rgba(0, 0, 0, 0.2); /* Fondo oscuro transparente */
    padding: 10px;
    margin: 4px;
    border-radius: 20px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    text-align: center;
    width: 200px;
}

.audio-player h2 {
    margin-bottom: 15px;
    color: #fff; /* Texto blanco para mejor visibilidad */
    font-size: 1.2em;
}

audio {
    width: 100%;
    outline: none;
}

.download-button {
    display: inline-block;
    margin-top: 10px;
    padding: 5px 10px; /* Botón más pequeño */
    background-image: linear-gradient(to right, #0066ff, #33ccff); /* Texto con gradiente */
    color: white; /* Texto en blanco */
    text-decoration: none; /* Sin subrayado */
    border-radius: 5px; /* Bordes redondeados */
    font-weight: bold;
    font-size: 0.9em; /* Texto más pequeño */
}
    body {
            margin: 0;
            padding: 0;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background-color: #100D0E !important; /* Black background */
            color: #fff; /* White text */
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
        }
        
        /* Navbar Styles */
        .navbar {
            padding: 0.5rem 1rem;
            background-color: #282828 !important;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            max-width: 1200px;
            position: relative;
            z-index: 1000; /* Ensures navbar is above dropdown menu */
            border: 1px solid #181818; /* Subtle border */
            border-radius: 20px; /* Rounded corners */
            margin-bottom: 10px; /* Space between navbar and features */
        }
        
        .navbar-brand {
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
            text-decoration: none;
        }
        
        .navbar-nav {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            margin: 0;
            padding: 0;
            list-style: none;
            flex-direction: row; /* Default alignment */
        }
        
        .navbar-nav .nav-link {
            color: #fff;
            margin-right: 20px;
            font-weight: 600;
            text-decoration: none;
            transition: color 0.3s ease;
        }
        
        .navbar-nav .nav-link:hover {
            color: #00cc99; /* Greenish hover effect */
        }
        
        .navbar-toggler {
            display: none;
            font-size: 1.5rem;
            color: #fff;
            background: none;
            border: none;
            cursor: pointer;
            position: relative;
            z-index: 1100; /* Above dropdown menu */
            width: 30px;
            height: 30px;
        }
        
        /* Hamburger Icon */
        .navbar-toggler .navbar-toggler-icon,
        .navbar-toggler .navbar-toggler-icon::before,
        .navbar-toggler .navbar-toggler-icon::after {
            display: block;
            background-color: #fff;
            height: 3px;
            width: 100%;
            border-radius: 2px;
            position: absolute;
            left: 0;
            transition: all 0.3s ease;
        }
        
        .navbar-toggler .navbar-toggler-icon {
            top: 50%;
            transform: translateY(-50%);
        }
        
        .navbar-toggler .navbar-toggler-icon::before {
            content: '';
            top: -8px;
        }
        
        .navbar-toggler .navbar-toggler-icon::after {
            content: '';
            top: 8px;
        }
        
        /* Transform into "X" when open */
        .navbar-toggler.open .navbar-toggler-icon {
            background: transparent;
        }
        
        .navbar-toggler.open .navbar-toggler-icon::before {
            transform: rotate(45deg) translate(5px, 5px);
        }
        
        .navbar-toggler.open .navbar-toggler-icon::after {
            transform: rotate(-45deg) translate(5px, -5px);
        }
        
        /* Content Balance */
        .content_balance {
            color: white;
            font-weight: bold;
            background-color: #28a745; /* Connected button background */
            padding: 5px 15px;
            border-radius: 20px;
            display: inline-block;
            bottom: 20px;
        }
        
        /* Feature Section */
        .features {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            margin: 20px 0;
            padding: 20px;
            width: 100%;
            max-width: 1200px;
        }
        
        .feature {
            /* Semi-transparent box */
            padding: 20px;
            width: 30%;
            border-radius: 10px;
            transition: transform 0.3s ease;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .feature:hover {
            transform: scale(1.05);
        }
        
        .feature h3 {
            background-image: linear-gradient(to right, #0066ff, #33ccff); /* Gradient text */
            color: transparent;
            -webkit-background-clip: text;
            font-size: 1.5rem;
            margin-bottom: 10px;
        }
        
        .feature p {
            color: #ccc; /* Light gray text */
            font-size: 1rem;
            text-align: left;
            margin-top: 12px;
        }
        
        /* Chat Container */
        .opaque-chat-wrapper {
            background-color: #100D0E; /* Opaque background for chat */
            padding: 20px;
            border-radius: 10px;
            width: 100%;
            max-width: 1200px;
            margin-bottom: 20px;
        }
        
        .chat {
            display: flex;
            flex-direction: column;
            min-height: 120vh;
            background-color: transparent; /* Transparent background inside opaque wrapper */
            border-radius: 10px;
            padding: 10px;
            width: 100%;
        }
        
        /* Chat Header */
        .chat-header {
            display: flex;
            align-items: center;
            padding: 5px;
            border-bottom: 1px solid #333;
            border-radius: 10px 10px 0 0;
        }
        
        .chat-header img {
            width: 50px;
            margin-right: 15px;
        }
        
        /* Chat Messages */
        .chat-messages {
            flex: 1 1 auto;
            padding: 20px;
            overflow-y: auto;
            background-color: #222; /* Dark background for messages */
            border-radius: 10px 10px 0px 0px;
            margin: 10px 0;
        }
        
        /* Chat Form */
        .chat-form {
            padding: 15px;
            display: flex;
            align-items: center;
            background-color: #111; /* Dark background for chat input */
            border-radius: 0 0 10px 10px;
            width: 50%;
            margin: 0 auto;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .chat-input {
            flex: 1;
            padding: 10px 15px;
            background-color: #333;
            color: #fff;
            border-radius: 25px;
            border: none;
            margin-right: 10px;
            font-size: 1rem;
            min-width: 200px;
        }
        
        .chat-input::placeholder {
            color: #ccc;
        }
        
        /* Chat Buttons */
        .chat-submit, .recordButton, #uploadButton {
            background: gray;
            padding: 10px;
            border-radius: 50%; /* Rounded buttons */
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s ease, background 0.3s ease;
            margin-right: 5px;
        }
        
        .chat-submit:hover, .recordButton:hover, #uploadButton:hover {
            transform: scale(1.1); /* Hover effect */
            background: linear-gradient(to right, #00cc99, #0056b3);
        }
        
        .chat-submit img, .recordButton img, #uploadButton img {
            width: 20px;
            height: 20px;
        }
.img_return{
    width: 100%;
}        
        /* Start Button */
        button#initBtn {
            background: gray;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s ease, transform 0.3s ease;
        }
        
        button#initBtn:hover {
            background: linear-gradient(to right, rgb(22, 214, 32), green);
            transform: scale(1.05);
        }
        
        /* General Chat Styles */
        .chat-messages {
            padding: 10px;
            background-color: #111;
            height: 50vh;
            width: 50%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        /* User Message Styles */
        .user-message-container {
            display: flex;
            justify-content: flex-end; /* Aligns to the right */
            margin-right: 10px;
        }
        
        .user-message-container .message-content {
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 10px 15px;
            border-radius: 15px 15px 0 15px;
            max-width: 60%;
            word-wrap: break-word;
            font-size: 14px;
            text-align: right;
        }
        
        /* Server Message Styles */
        .server-message-container {
            display: flex;
            justify-content: flex-start; /* Aligns to the left */
            margin-left: 10px;
            
        }
        
        .server-message-container .message-content {
            background: linear-gradient(45deg, #00CC66, #0056b3);
            color: white;
            padding: 10px 15px;
            border-radius: 15px 15px 15px 0;
            max-width: 60%;
            word-wrap: break-word;
            font-size: 14px;
            text-align: left;
        }
        
        /* Message Images */
        .message-images {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        
        .message-images img {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            object-fit: cover;
        }
        
        /* Header Titles */
        .header_title1, .header_title2, .header_title3 {
            background-size: cover; /* Ensures the image covers the div */
            background-position: center; /* Centers the image within the div */
            background-repeat: no-repeat; /* Prevents image repetition */
            width: 100%; /* Adjusts the div width */
            border-radius: 10px;
            height: 60px; /* Adjusts height based on design */
            display: flex;
            align-items: center; /* Centers content vertically */
            justify-content: center; /* Centers content horizontally */
            color: white; /* Changes text color if necessary */
            font-size: 1.5rem;
            text-align: center;
            padding: 0 5px;
        }
        
        .header_title1 {
            background-image: url("{{ url_for('static', filename='images/feature1.jpg', cache_timeout=0) }}");
        }
        
        .header_title2 {
            background-image: url("{{ url_for('static', filename='images/feature2.jpg', cache_timeout=0) }}");
        }
        
        .header_title3 {
            background-image: url("{{ url_for('static', filename='images/feature3.jpg', cache_timeout=0) }}");
        }
        
        /* Preview Window Styles */
        .preview-window {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 400px;
            max-width: 90%;
            height: 300px;
            background-color: #fff;
            border: 1px solid #333;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            display: none; /* Hidden by default */
            transition: all 0.3s ease;
        }

        /* Maximized Preview Styles */
        .preview-window.maximized {
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 0;
        }

        /* Responsive Design for Preview Window */
        @media (min-width: 1024px) {
            .preview-window {
                width: 600px;
                height: 500px;
            }
        }

        @media (max-width: 600px) {
            .preview-window {
                width: 90%;
                height: 300px;
            }
        }
    
        .preview-window iframe {
            flex: 1;
            border: none;
            width: 100%;
            height: 100%;
        }
    
        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #333;
            color: #fff;
            padding: 10px;
        }
    
        .preview-header button {
            background: none;
            border: none;
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
            margin-left: 5px;
        }

        /* Maximize/Minimize Button */
        #maximize-preview-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: 1.2rem;
            cursor: pointer;
            margin-left: 10px;
        }

        /* Export Buttons */
        .export-buttons {
            display: flex;
            gap: 10px;
        }
    
        /* Show Preview Button When Minimized */
        #show-preview-btn {
            display: none; /* Hidden by default */
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #333;
            color: #fff;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 2000;
        }
    
        /* Drag and Drop Styles */
        #drag-drop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            color: #fff;
            z-index: 1500;
            flex-direction: column;
        }
    
        #drag-drop-overlay p {
            margin-bottom: 10px;
            font-size: 1.2rem;
        }
    
        #drag-drop-button {
            background-color: #00cc99;
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
        }
    
        #drag-drop-button:hover {
            background-color: #0056b3;
        }
    
        /* Preview Images Container */
        #preview-images {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
            justify-content: center;
        }
    
        /* Additional Styles */
        .feature {
            margin-bottom: 20px; /* Separation between features */
        }
        
        .feature h3 {
            margin: 0; /* Removes margin for better alignment */
            color: white;
        }
        
        p {
            font-size: 19px;
            line-height: 1.5;
        }
        
        a {
            margin-left: 50px;
            color: #00cc99;
            text-decoration: none;
            transition: color 0.3s ease;
        }
        
        a:hover {
            color: #33ffcc;
        }
        
        /* Media Queries for Responsive Design */
        
        /* Tablets and smaller devices */
        @media (max-width: 1024px) {
            .feature {
                width: 45%;
            }
        }
        
        @media (max-width: 768px) {
            .chat-messages{
                width: 90%;
            }
            .chat-form{
                width: 90%;
            }
            /* Navbar adjustments */
            .navbar-nav {
                flex-direction: column;
                width: 100%;
                display: none;
                background-color: #100D0E; /* Black background for dropdown menu */
                position: fixed;
                top: 0;
                left: 0;
                height: 100vh;
                padding-top: 60px; /* Space for navbar */
                transition: transform 0.3s ease-in-out;
                transform: translateY(-100%);
            }

            .navbar-nav.show {
                display: flex;
                transform: translateY(0);
            }

            .navbar-nav .nav-link {
                margin: 20px 0;
                font-size: 1.5rem;
                text-align: center;
            }

            .navbar-toggler {
                display: block;
            }

            /* Feature adjustments */
            .feature {
                width: 100%;
            }
        
            /* Chat adjustments */
            .user-message-container {
                padding-left: 10%;
            }
        
            .server-message-container {
                padding-right: 10%;
            }
        
            .message-images img {
                width: 50px;
                height: 50px;
            }
        }
        
        @media (max-width: 600px) and (orientation: landscape) {
            .image-section .overlay-text {
                font-size: 40px;
            }
        
            .header_title {
                height: 80px;
                font-size: 1.2rem;
            }
        
            .chat-header img {
                width: 40px;
                margin-right: 10px;
            }
        
            .chat-input {
                padding: 10px 12px;
                font-size: 0.9rem;
            }
        
            button#initBtn {
                padding: 8px 16px;
                font-size: 0.9rem;
            }
        
            .chat-submit img, .recordButton img, #uploadButton img {
                width: 18px;
                height: 18px;
            }
        
            .content_balance {
                padding: 5px 10px;
                font-size: 0.9rem;
            }
        }
        
        @media (max-width: 480px) {
            /* General adjustments */
            body {
                height: auto;
                padding: 20px 0;
            }
        
            .container, .chat {
                border-radius: 0;
                padding: 10px;
            }
        
            .image-section .overlay-text {
                font-size: 30px; /* Further reduce font size for smaller screens */
            }
        
            .header_title {
                height: 60px;
                font-size: 1rem;
            }
        
            h1 {
                font-size: 18px;
            }
        
            p {
                font-size: 15px;
            }
        
            .input-group label, .input-group input, button, .google-signin, .additional-links a {
                font-size: 14px;
            }
        
            .navbar-nav .nav-link {
                margin-right: 10px;
            }
        
            .feature h3 {
                font-size: 1.2rem;
            }
        
            .feature p {
                font-size: 0.9rem;
            }
        
            .chat-header img {
                width: 40px;
                margin-right: 10px;
            }
        
            .chat-input {
                padding: 10px 12px;
                font-size: 0.9rem;
            }
        
            button#initBtn {
                padding: 8px 16px;
                font-size: 0.9rem;
            }
        
            .chat-submit img, .recordButton img, #uploadButton img {
                width: 18px;
                height: 18px;
            }
        
            .content_balance {
                padding: 5px 10px;
                font-size: 0.9rem;
            }
        
            /* Feature section */
            .features {
                padding: 5px;
            }
        }
        #chat-input {
    overflow: hidden;
    overflow-y: scroll; /* Permitir el scroll vertical */
    scrollbar-width: none; /* Firefox: Ocultar la barra de scroll */
    -ms-overflow-style: none; /* IE y Edge: Ocultar la barra de scroll */
  }

  #chat-input::-webkit-scrollbar {
    display: none; /* Chrome, Safari y Opera: Ocultar la barra de scroll */
  }
    </style>
</head>
<body>
    <!-- Chat Menu Wrapped in an Opaque Div -->
    <div class="opaque-chat-wrapper" id="opaque-chat-wrapper">
        <div class="chat" id="chat">
            <div class="chat-header">
                <nav class="navbar navbar-expand-lg navbar-light bg-light" style="background-color: transparent !important;">
                    <a class="navbar-brand" href="/">
                        <img src="{{ url_for('static', filename='images/ico.svg', cache_timeout=0) }}" style="width: 50px;" alt="Logo">
                    </a>
                    <button class="navbar-toggler" type="button">
                        <span class="navbar-toggler-icon"></span>
                    </button>
                   
                    <div class="navbar-nav mr-auto">
                        <a class="nav-item nav-link" style="color: white" id="logout-btn">New Chat</a>
                        <a class="nav-item nav-link" style="color: white" id="logout">Login</a>
                        <a class="nav-item nav-link" style="color: white" href="/sign-up">Sign Up</a>
                        <a class="nav-item nav-link" style="color: white" href="/deposit_tokens" target="_blank">Deposit</a>
                    </div>
                    <div class="header_title3" style="width: 100px; height: 35px; font-size:16px;" id="balance_account">
                        Connected
                    </div>
                    <!-- Show Preview Button -->
                    <button id="show-preview-btn">Show Preview</button>
                </nav>
            </div>
            <!-- Features Section Outside the Opaque Chat Div -->
            <div class="features">
                <!-- Feature 1: Knowledge of Dalas Review & Crypto Projects -->
                <div class="feature">
                    <div class="header_title1">
                        <h3>Knowledge of Dalas Review</h3>
                    </div>
                    <p>
                        MINI AI possesses in-depth knowledge about Dalas Review and his crypto projects. Whether you have questions about his content, career, or the details of his cryptocurrency projects, MINI AI offers thorough and insightful responses.
                    </p>
                </div>
            
                <!-- Feature 2: Multimedia & Web Creation -->
                <div class="feature">
                    <div class="header_title2">
                        <h3>Multimedia & Web Creation</h3>
                    </div>
                    <p>
                        MINI AI can create music, images, videos, and integrate these multimedia elements into web pages. It can generate complete websites and HTML5 structures, embedding the media it produces directly within the generated web content.
                    </p>
                </div>
            
                <!-- Feature 3: Publish & Monetize Web Pages -->
                <div class="feature">
                    <div class="header_title3">
                        <h3>Publish & Monetize Web Pages</h3>
                    </div>
                    <p>
                        Users can publish web pages created with MINI AI and accept donations with no fees, receiving 100% of the support from their audience to monetize their work.
                    </p>
                </div>
            </div>
                        <center>
                <div class="chat-messages" id="chat-messages" style="margin: 0px; overflow-x: hidden; overflow-y: scroll; scrollbar-width: none; -ms-overflow-style: none;">
                    <div class="container_text_area">
                        <!-- Features Outside the Opaque Chat Div -->
                    </div>
                </div>
                <!-- Chat Form -->
                <form class="chat-form" id="chat-form" style=" margin: 0px;" data-hashsesion="{{ hashchat }}">
                    <textarea class="chat-input" id="chat-input" placeholder="Write your message..."></textarea>
                    <button type="submit" class="chat-submit" aria-label="Send">
                        <img src="{{ url_for('static', filename='images/send.png', cache_timeout=0) }}" style="width: 30px; height: 30px;" class="send-icon" alt="Send">
                    </button>
                    <button type="button" id="recordButton" aria-label="Record" class="recordButton" style="margin-left: 10px;">
                        <img src="{{ url_for('static', filename='images/microphone.png', cache_timeout=0) }}" style="width: 30px; height: 30px;" class="record-icon" alt="Record">
                    </button>
                </form>
                <!-- Preview Images -->
                <div id="preview-images"></div>
            </center>
            <!-- Drag and Drop Overlay -->
            <div id="drag-drop-overlay">
                <p>Drag an image here or click to upload</p>
                <input type="file" id="drag-drop-input" accept=".png, .jpg, .jpeg" style="display:none;">
                <button id="drag-drop-button">Upload File</button>
            </div>
        </div>
    </div>
    
    <!-- Preview Window -->
    <div class="preview-window" id="preview-window">
        <div class="preview-header">
            <span>Preview</span>
            <div class="export-buttons">
                <button id="download-html">Export HTML</button>
                <button id="download-pdf">Export PDF</button>
                <form id="publish-form">
                <button type="button" id="connect-wallet-button">Publish web</button>
                </form>
            </div>
            <div>
                <button id="minimize-preview-btn">_</button>
                <button id="maximize-preview-btn">+</button>
            </div>
        </div>
        <iframe id="preview-iframe" sandbox="allow-scripts allow-same-origin"></iframe>

    </div>
    
    <!-- Button to Show Preview When Minimized -->
    <button id="show-preview-btn">Show Preview</button>
    
    <!-- Additional Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.4.0/purify.min.js"></script>

    <!-- Scripts to Handle Responsive Menu and Additional Functionalities -->
    <script>
$(document).ready(function() {
    // Toggle navbar
    $('.navbar-toggler').click(function() {
        $(this).toggleClass('open');
        $('.navbar-nav').toggleClass('show');
    });

    // Functions to Handle the Preview Window
    const minimizePreviewBtn = document.getElementById('minimize-preview-btn');
    const maximizePreviewBtn = document.getElementById('maximize-preview-btn');
    const showPreviewBtn = document.getElementById('show-preview-btn');
    let previewWindow = document.getElementById('preview-window');
    let isMaximized = false;

    // Correct iframe ID
    let previewIframe = document.getElementById('preview-iframe');

    // Ensure previewWindow exists
    if (!previewWindow) {
        console.warn("The container with ID 'preview-window' was not found in the DOM. Creating one dynamically.");
        previewWindow = document.createElement('div');
        previewWindow.id = 'preview-window';
        // Basic styles for the container
        previewWindow.style.display = 'none'; // Initially hidden
        previewWindow.style.position = 'fixed';
        previewWindow.style.top = '0';
        previewWindow.style.right = '0';
        previewWindow.style.width = '50%';
        previewWindow.style.height = '100%';
        previewWindow.style.backgroundColor = '#ffffff';
        previewWindow.style.zIndex = '1000';
        previewWindow.style.boxShadow = '-2px 0 5px rgba(0,0,0,0.3)';
        previewWindow.style.flexDirection = 'column'; // Ensure child elements are aligned vertically
        previewWindow.style.overflow = 'hidden'; // Prevent content overflow
        document.body.appendChild(previewWindow);
    }

    // Add event listeners for minimize and maximize buttons
    if (minimizePreviewBtn && showPreviewBtn && maximizePreviewBtn) {
        minimizePreviewBtn.addEventListener('click', function() {
            previewWindow.style.display = 'none';
            showPreviewBtn.style.display = 'block';
            // If maximized, reset the state
            if (isMaximized) {
                previewWindow.classList.remove('maximized');
                isMaximized = false;
                maximizePreviewBtn.textContent = '+';
            }
        });

        maximizePreviewBtn.addEventListener('click', function() {
            if (!isMaximized) {
                previewWindow.classList.add('maximized');
                isMaximized = true;
                maximizePreviewBtn.textContent = '↺'; // Change icon to indicate restore
            } else {
                previewWindow.classList.remove('maximized');
                isMaximized = false;
                maximizePreviewBtn.textContent = '+'; // Change icon back to maximize
            }
        });

        showPreviewBtn.addEventListener('click', function() {
            previewWindow.style.display = 'flex';
            showPreviewBtn.style.display = 'none';
        });
    } else {
        console.warn("The buttons 'minimize-preview-btn', 'show-preview-btn', or 'maximize-preview-btn' were not found in the DOM.");
    }

    // Drag and Drop and Message Handling
    // Global Variables
    let imagesBase64 = [];
    const chatContainer = document.getElementById('opaque-chat-wrapper');
    const dragDropOverlay = document.getElementById('drag-drop-overlay');
    const dragDropInput = document.getElementById('drag-drop-input');
    const dragDropButton = document.getElementById('drag-drop-button');
    const chatMessages = document.getElementById('chat-messages');
    const chatForm = document.getElementById('chat-form');
    const chatInput = document.getElementById('chat-input');
    const recordButton = document.getElementById('recordButton');
    const balanceAccount = document.getElementById('balance_account');
    const downloadHtmlBtn = document.getElementById('download-html');
    const downloadPdfBtn = document.getElementById('download-pdf');

    // Initialize if iframe does not exist
    if (!previewIframe) {
        console.warn("The iframe with ID 'preview-iframe' was not found in the DOM. Creating one dynamically.");
        previewIframe = document.createElement('iframe');
        previewIframe.id = 'preview-iframe';
        // Styles to make iframe occupy entire previewWindow
        previewIframe.style.flex = '1';
        previewIframe.style.width = '100%';
        previewIframe.style.height = '100%';
        previewIframe.style.border = 'none';
        previewWindow.appendChild(previewIframe); // Insert into previewWindow
    }

    // Initialize message history counter
    let len_list_history = 0;

    // Implement a counter to prevent overlay flickering
    let dragCounter = 0;

    // Function to handle image files
    function handleImageFiles(files) {
        Array.from(files).forEach(file => {
            if (!file.type.match('image.*')) {
                console.error("The file is not an image.");
                return;
            }

            if (!['image/png', 'image/jpg', 'image/jpeg'].includes(file.type)) {
                console.error("Unsupported image format.");
                return;
            }

            const reader = new FileReader();
            reader.onloadend = () => {
                const base64String = reader.result.split(',')[1];
                imagesBase64.push(base64String);

                const imgContainer = document.getElementById("preview-images");
                if (!imgContainer) {
                    console.error("The preview images container was not found in the DOM.");
                    return;
                }

                const img = document.createElement("img");
                img.src = reader.result;
                img.style.width = "50px";
                img.style.height = "50px";
                img.style.margin = "5px";
                img.style.borderRadius = "5px";

                imgContainer.appendChild(img);
            };
            reader.readAsDataURL(file);
        });

        dragDropOverlay.style.display = 'none';
    }

    // Drag and Drop Events with counter to prevent flickering
    if (chatContainer && dragDropOverlay) {
        chatContainer.addEventListener('dragenter', function(e) {
            e.preventDefault();
            dragCounter++;
            dragDropOverlay.style.display = 'flex';
        });

        chatContainer.addEventListener('dragleave', function(e) {
            e.preventDefault();
            dragCounter--;
            if (dragCounter === 0) {
                dragDropOverlay.style.display = 'none';
            }
        });

        chatContainer.addEventListener('dragover', function(e) {
            e.preventDefault();
        });

        chatContainer.addEventListener('drop', function(e) {
            e.preventDefault();
            dragCounter = 0;
            dragDropOverlay.style.display = 'none';
            const files = e.dataTransfer.files;
            handleImageFiles(files);
        });
    } else {
        console.warn("The 'opaque-chat-wrapper' or 'drag-drop-overlay' container was not found in the DOM.");
    }

    // Handle drag-drop button click
    if (dragDropButton && dragDropInput) {
        dragDropButton.addEventListener('click', function() {
            dragDropInput.click();
        });

        dragDropInput.addEventListener('change', function() {
            const files = dragDropInput.files;
            handleImageFiles(files);
        });
    } else {
        console.warn("The 'drag-drop-button' or 'drag-drop-input' was not found in the DOM.");
    }

    // Handle chat form submission with images
    if (chatForm && chatInput) {
        chatForm.addEventListener("submit", async (event) => {
            event.preventDefault();
            const message = chatInput.value.trim();
            if (message === '') return;
            chatInput.value = "";

            const response = await sendMessageWithImages(message);
            imagesBase64 = [];
            dragDropInput.value = "";
            const imgContainer = document.getElementById("preview-images");
            if (imgContainer) {
                imgContainer.innerHTML = "";
            }

            if (response.ok) {
                // Message handling is managed by history update to avoid duplication
            } else {
                console.error("Error uploading message and images:", response.statusText);
            }
        });
    } else {
        console.warn("The 'chat-form' or 'chat-input' was not found in the DOM.");
    }

    // Function to send message and images to the server
    async function sendMessageWithImages(message) {
        return fetch("/chat/message", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "audio/wav"
            },
            body: JSON.stringify({
                message: message,
                images_list: imagesBase64,
                hashchat: "{{hashchat}}", // Ensure these variables are correctly replaced on the server
                usernickname: "{{Username}}"
            })
        });
    }

    // Function to append messages to the chat container
    function appendMessage(content, role, sanitized = true) {
        const messageDiv = document.createElement('div');

        if (role === 'user') {
            messageDiv.classList.add('user-message-container');
            const messageContent = document.createElement('div');
            messageContent.classList.add('message-content');
            messageContent.innerHTML = content;
            messageDiv.appendChild(messageContent);
        } else if (role === 'server') {
            messageDiv.classList.add('server-message-container');
            const messageContent = document.createElement('div');
            messageContent.classList.add('message-content');
            if (sanitized) {
                content = DOMPurify.sanitize(content, { ADD_TAGS: ['script', 'style'], ADD_ATTR: ['src', 'type'] });
            }
            messageContent.innerHTML = content;
            messageDiv.appendChild(messageContent);
        }

        if (chatMessages) {
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        } else {
            console.error("The 'chat-messages' container was not found in the DOM.");
        }
    }

    // Function to handle deploy_item messages
    function handleDeployItem(message) {
        // Ensure previewIframe exists before attempting to use it
        if (!previewIframe) {
            console.error("The iframe with ID 'preview-iframe' was not found in the DOM.");
            return;
        }

        // Ensure the message is a valid string
        if (typeof message !== 'string' || message.trim() === '') {
            console.error("The message provided for deploy_item is invalid.");
            return;
        }

        const blob = new Blob([message], { type: 'text/html' });
        const url = URL.createObjectURL(blob);

        // Set the src of the iframe and display it
        previewIframe.src = url;
        previewIframe.style.display = 'block'; // Ensure the iframe is visible
        previewWindow.style.display = 'flex'; // Show the preview window
        showPreviewBtn.style.display = 'none'; // Hide the show preview button
    }

    // Function to verify server responses
    function verify_res_server(data_res) {
        switch (data_res.role) {
            case "server":
                let message_render;
                if (data_res.message === "Error_Interpreter_modific_element") {
                    current_interaction = null;
                    message_render = "Sorry, it was my mistake, I didn't correctly interpret what you said. Let's continue creating the document, what do you think?";
                } else {
                    const textArea = document.createElement('textarea');
                    textArea.innerHTML = data_res.message;
                    message_render = textArea.value;
                }
                appendMessage(message_render, 'server');
                return false;

            case "user":
                const userIndex = parseInt(data_res.user_index);
                if (userIndex >= 1) {
                    appendMessage(data_res.message, 'user');
                } else {
                    console.error("Invalid user index:", userIndex);
                }
                return false;

            case "deploy_item":
                handleDeployItem(data_res.message);
                return false;

            default:
                return false;
        }
    }

    // Function to update message history
    async function updateMessagesHistory() {
        const payload = {
            hashsesion: "{{hashchat}}", // Ensure this variable is correctly replaced on the server
            len_list_history: len_list_history
        };

        try {
            const response = await fetch('/update_messages_history', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });

            // Check response content type
            const contentType = response.headers.get("content-type");
            if (!contentType || !contentType.includes("application/json")) {
                throw new TypeError("Response is not JSON");
            }

            const result = await response.json();

            if (response.ok) {
                if (result.message === "not_update_history_chat") {
                    // No new messages
                    return;
                } else if (result.message === "Error login session") {
                    console.error('Session error:', result.message);
                    clearInterval(pollingInterval);
                    return;
                } else if (Array.isArray(result)) {
                    // Get new messages
                    const newMessages = result.slice(len_list_history);

                    // Check if there are new messages before processing
                    if (newMessages.length > 0) {
                        newMessages.forEach(msg => {
                            verify_res_server(msg);
                        });

                        len_list_history = result.length;
                    }
                }
            } else {
                console.error('Error updating history:', result.message);
            }
        } catch (error) {
            if (error.name === 'TypeError' && error.message === "Response is not JSON") {
                console.error('Error updating history: Response is not JSON. Possible server error.');
            } else if (error.response && error.response.status === 429) {
                console.error('Error updating history: Too many requests (429). Consider reducing request frequency.');
                // Optional: Implement exponential backoff logic here
            } else {
                console.error('Error updating history:', error);
            }
        }
    }

    // Start periodic message history updates every 5 seconds
    const pollingInterval = setInterval(updateMessagesHistory, 5000); // 5000 ms = 5 seconds

    // Call the function once on page load to get initial history 
    updateMessagesHistory();

    // Voice Recognition Handling
    let recognition;
    let isRecording = false;

    document.getElementById('recordButton').addEventListener('click', function() {
    if (!recognition) {
        recognition = new webkitSpeechRecognition();
        recognition.lang = 'es-ES';
        recognition.continuous = true;
        recognition.interimResults = true;

        let previousTranscript = '';

        recognition.onresult = function(event) {
            let newTranscript = '';

            for (let i = event.resultIndex; i < event.results.length; ++i) {
                if (event.results[i].isFinal) {
                    newTranscript = event.results[i][0].transcript;
                }
            }

        if (newTranscript && newTranscript !== previousTranscript) {
            let uniquePart = newTranscript.replace(previousTranscript, '').trim();
                if (uniquePart) {
                    chatInput.value += uniquePart + ' ';
                }

                previousTranscript = newTranscript;
            }
        };
    }

    if (isRecording) {
        recognition.stop();
        this.classList.remove('recording');
        this.querySelector('img').src = "{{ url_for('static', filename='images/microphone.png', cache_timeout=0) }}";
    } else {
        recognition.start();
        this.classList.add('recording');
        this.querySelector('img').src = "{{ url_for('static', filename='images/stop-button.png', cache_timeout=0) }}";
    }
    isRecording = !isRecording;
});
    // Handle logout
    function handleLogout() {
        fetch('/logout', {
            method: 'POST',
        })
            .then(response => {
                if (response.ok) {
                    window.location.href = "/login";
                } else {
                    alert('Logout failed');
                }
            })
            .catch(error => {
                console.error('Error:', error);
            });
    }

    const logoutButtons = document.querySelectorAll('#logout-btn, #logout');
    logoutButtons.forEach(button => {
        if (button) {
            button.addEventListener('click', handleLogout);
        } else {
            console.warn('One of the logout buttons was not found in the DOM.');
        }
    });

    // Functions to Export the Preview
    function convertImgToDataURLviaCanvas(url, callback, outputFormat = 'image/png') {
        var img = new Image();
        img.crossOrigin = 'Anonymous';
        img.onload = function() {
            var canvas = document.createElement('CANVAS');
            var ctx = canvas.getContext('2d');
            canvas.height = this.naturalHeight;
            canvas.width = this.naturalWidth;
            ctx.drawImage(this, 0, 0);
            var dataURL = canvas.toDataURL(outputFormat);
            callback(dataURL);
        };
        img.onerror = function() {
            console.error("Failed to load image: " + url);
            callback(null);
        };
        img.src = url;
        if (img.complete || img.complete === undefined) {
            img.src = url;
        }
    }

    function waitForImagesToLoad(container, callback) {
        const images = container.getElementsByTagName('img');
        let loadedImagesCount = 0;
        const totalImages = images.length;

        if (totalImages === 0) {
            callback();
            return;
        }

        for (let i = 0; i < totalImages; i++) {
            images[i].onload = images[i].onerror = () => {
                loadedImagesCount++;
                if (loadedImagesCount === totalImages) {
                    callback();
                }
            };
        }
    }

    if (downloadHtmlBtn) {
        downloadHtmlBtn.addEventListener('click', function() {
            if (!previewIframe) {
                console.error("The iframe with ID 'preview-iframe' was not found in the DOM.");
                return;
            }

            try {
                const iframeDocument = previewIframe.contentDocument || previewIframe.contentWindow.document;

                // Clone the iframe's document to avoid unwanted modifications
                const clonedDoc = iframeDocument.documentElement.cloneNode(true);

                // Embed all stylesheets
                const styles = iframeDocument.querySelectorAll("link[rel='stylesheet'], style");
                styles.forEach(style => {
                    clonedDoc.querySelector('head').appendChild(style.cloneNode(true));
                });

                // Embed all scripts if necessary
                const scripts = iframeDocument.querySelectorAll("script[src], script:not([src])");
                scripts.forEach(script => {
                    clonedDoc.querySelector('body').appendChild(script.cloneNode(true));
                });

                // Serialize the cloned document
                const serializedContent = clonedDoc.outerHTML;

                // Create and download the HTML Blob
                const blob = new Blob([serializedContent], { type: 'text/html' });
                saveAs(blob, 'document.html');
            } catch (error) {
                console.error("Error accessing the iframe's document:", error);
            }
        });
    } else {
        console.warn("The 'download-html' button was not found in the DOM.");
    }

    // Event Handler to Export to PDF
    if (downloadPdfBtn) {
        downloadPdfBtn.addEventListener('click', function() {
            if (!previewIframe) {
                console.error("The iframe with ID 'preview-iframe' was not found in the DOM.");
                return;
            }

            try {
                const iframeDocument = previewIframe.contentDocument || previewIframe.contentWindow.document;
                const element = iframeDocument.documentElement;

                waitForImagesToLoad(element, () => {
                    const printWindow = window.open('', '', 'height=600,width=800');
                    printWindow.document.write('<html><head><title>Preview PDF</title>');

                    // Get styles from the iframe's document
                    const styles = Array.from(iframeDocument.querySelectorAll("link[rel='stylesheet'], style")).map(style => style.outerHTML).join('');
                    printWindow.document.write(styles);

                    printWindow.document.write('</head><body>');
                    printWindow.document.write(element.outerHTML);

                    // Get scripts from the iframe's document if necessary
                    // Note: Including scripts may affect functionality in the print window
                    const scripts = Array.from(iframeDocument.querySelectorAll("script[src], script:not([src])")).map(script => script.outerHTML).join('');
                    printWindow.document.write(scripts);

                    printWindow.document.write('</body></html>');
                    printWindow.document.close();

                    printWindow.onload = () => {
                        setTimeout(() => {
                            printWindow.print();
                            printWindow.close();
                        }, 1000);
                    };
                });
            } catch (error) {
                console.error("Error accessing the iframe's document:", error);
            }
        });
    } else {
        console.warn("The 'download-pdf' button was not found in the DOM.");
    }
    
});    
</script>
    
</body>
</html>

  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
